# linux-char-driver

## Задание Linux kernel

Реализовать символьный драйвер предлагающий возможность передавать информацию двум независимым процессам через файл символьного устройства: 

 - взаимодействие должно осуществляться по принципу кольцевого буфера;  т.е. один процесс может писать в файл символьного устройства, а другой из него читать.
 - обеспечить возможность задавать размер кольцевого буфера через механизм параметров модулей ядра; 
 - по умолчанию вызовы чтения и записи должны быть блокирующими;
 - обеспечить поддержку нескольких вызовов IOCTL:
   - переключение режима работы вызовов read\write из блокирующих \ не блокирующих и обратно;
   - обеспечить возможность получения информации о времени последней операции чтения и записи в буфер, а так же идентификаторов и владельцев процессов совершивших эту операцию;
 - драйвер должен собираться вне дерева исходных кодов ядра при помощи Makefile;
 - исходные коды драйвера должны находиться под системой контроля версий git и содержать историю коммитов;
 - результат передаётся в виде ссылки на репозиторий размещённый на github или в виде архива содержащего репозиторий с исходными кодами.

## Сборка драйвера
Собрать проект:
```sh
git clone https://github.com/AndreyYunak/linux-char-driver.git
cd linux-char-driver

make
make clean
```
Для сборки требуются Linux headers. По умолчанию они ищутся по пути:
KERN_DIR ?= /usr/src/linux-headers-$(shell uname -r)/
## Использование драйвера
После сборки драйвера модуль необходимо подключить:
```sh
insmod chdr.ko
```
Если необходимо задать размер буфера (x размер буфера в байтах):
```sh
insmod chdr.ko buffer_size=x
```
Создать символьный файл:
```sh
mknod /dev/chdr c 240 0
```
Два целых параметра (240 0) задают старший и младший номера устройства. Эти номера драйвер выводит при подключении. 
Номер устройства можно найти в строке:
```sh
buffer_pipe: was initialised. major: 240, minor: 0
```
в выводе команды:
```sh
dmesg
```

## IOCTL вызовы
Переключение режима работы вызовов read\write из блокирующих \ не блокирующих и обратно выполняютс с помощью стандартного вызова:
```c
ioctl(fd, FIONBIO, &f)
```
где fd - файловый дескриптор файла устройства, f - переменная устанавливающая блокирующий (0) и не блокирующий (1) вызовы.

